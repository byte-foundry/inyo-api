type Address {
  id: ID! @unique
  street: String
  city: String
  postalCode: String
  country: String
}

# Represents a company or an individual that is going to receive an invoice
type Customer {
  id: ID! @unique
  name: String
  firstName: String
  lastName: String
  email: String!
  address: Address
  phone: String
  siret: String
  rcs: String
  rm: String
  serviceCompany: Company! @relation(name: "CompanyCustomers")
  quotes: [Quote!]! @relation(name: "CustomerQuotes")
}

enum QuoteStatus {
  DRAFT
  SENT
  ACCEPTED
  REJECTED
  INVOICED
  INVOICED_ACCEPTED
}

enum QuoteTemplate {
  BLANK
  WEBSITE
  IDENTITY
}

enum ItemStatus {
  PENDING
  FINISHED
  UPDATED
  UPDATED_SENT
}

enum ReminderType {
  QUOTE_AFTER_1MONTH
  QUOTE_AFTER_2MONTH
  QUOTE_20_DAYS_LEFT
  QUOTE_10_DAYS_LEFT
  QUOTE_5_DAYS_LEFT
  AMENDMENT_AFTER_5_DAYS
  AMENDMENT_AFTER_10_DAYS
}

enum ReminderStatus {
  PENDING
  SENT
  ERROR
}

type Comment {
  id: ID! @unique
  text: String!
  authorUser: User
  authorCustomer: Customer
  viewedByUser: Boolean! @default(value: false)
  viewedByCustomer: Boolean! @default(value: false)
  item: Item! @relation(name: "ItemComments")
}

type Item {
  id: ID! @unique
  name: String!
  description: String @default(value: "")
  unitPrice: Int! @default(value: 0)
  # when unit has been changed but not yet validated
  pendingUnit: Float
  unit: Float @default(value: 0)
  comments: [Comment!]! @relation(name: "ItemComments")
  vatRate: Int! @default(value: 0)
  status: ItemStatus! @default(value: PENDING)
  section: Section! @relation(name: "SectionItems")
}

type Section {
  id: ID! @unique
  name: String!
  items: [Item!]! @relation(name: "SectionItems", onDelete: CASCADE)
  option: Option! @relation(name: "OptionSections")
}

type Option {
  id: ID! @unique
  name: String!
  proposal: Json! @default(value: "{}")
  sections: [Section!]! @relation(name: "OptionSections", onDelete: CASCADE)
  quote: Quote! @relation(name: "QuoteOptions")
}

type Quote {
  id: ID! @unique
  name: String!
  template: QuoteTemplate @default(value: BLANK)
  customer: Customer! @relation(name: "CustomerQuotes")
  # this token is a way to restrict access to anyone else than the customer
  token: String!
  status: QuoteStatus! @default(value: DRAFT)
  options: [Option!]! @relation(name: "QuoteOptions", onDelete: CASCADE)
  viewedByCustomer: Boolean! @default(value: false)
  reminders: [Reminder!]! @relation(name: "QuoteReminders", onDelete: CASCADE)
  issuedAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Company {
  id: ID! @unique
  name: String
  owner: User! @relation(name: "CompanyOwner")
  email: String
  address: Address
  phone: String
  type: String
  siret: String
  rcs: String
  rcsCity: String
  rm: String
  vat: String
  customers: [Customer!]! @relation(name: "CompanyCustomers")
}

type User {
  id: ID! @unique
  email: String! @unique
  password: String!
  firstName: String
  lastName: String
  company: Company! @relation(name: "CompanyOwner")
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Reminder {
  id: ID! @unique
  quote: Quote! @relation(name: "QuoteReminders")
  postHookId: String!
  type: ReminderType!
  sendingDate: DateTime!
  status: ReminderStatus @default(value: PENDING)
}
